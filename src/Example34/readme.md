## Потокобезопасные коллекции

### 1. **Проблема с обычными коллекциями**
Начать с демонстрации, почему `List`, `Dictionary` и другие стандартные коллекции небезопасны в многопоточности. Показать классический пример race condition.

### 2. **Решение: System.Collections.Concurrent**
Представить пространство имен как современное решение для многопоточности, появившееся в .NET Framework 4.

### 3. **Основные классы по категориям**

**Общего назначения:**
# `ConcurrentDictionary` - потокобезопасный словарь

## Ключевые отличия

| Критерий | Dictionary | ConcurrentDictionary |
|----------|------------|----------------------|
| **Потокобезопасность** | ❌ Нет | ✅ Полная |
| **Метод Add()** | ✅ Есть | ❌ Нет - только TryAdd() |
| **Исключения при добавлении** | ArgumentException если ключ существует | Возвращает false |
| **Атомарные операции** | ❌ Нет | ✅ AddOrUpdate, GetOrAdd |
| **Производительность** | Быстрее в однопоточности | Медленнее из-за синхронизации |
| **Перебор** | Снимок на момент итерации | Может изменяться во время перебора |

### Главное различие в философии

**Dictionary**: "Быстро и небезопасно" - при конкурентном доступе нужны внешние блокировки  
**ConcurrentDictionary**: "Безопасно из коробки" - все операции атомарные, но медленнее

**Практическое правило**: Используйте `ConcurrentDictionary` когда несколько потоков одновременно читают/пишут. Для однопоточного кода оставайтесь с обычным `Dictionary`.

**Специального назначения:**
# `ConcurrentQueue` - FIFO очередь

## Ключевые отличия

| Критерий | Queue | ConcurrentQueue |
|----------|-------|-----------------|
| **Потокобезопасность** | ❌ Нет | ✅ Полная |
| **Dequeue()** | ✅ Есть, бросает исключение | ❌ Нет - только TryDequeue() |
| **Peek()** | ✅ Есть, бросает исключение | ❌ Нет - только TryPeek() |
| **Count** | Точное значение | ⚠️ Приблизительное (может изменяться) |
| **IsEmpty** | ❌ Нет | ✅ Есть (но может измениться сразу после проверки) |
| **Исключения** | InvalidOperationException при пустой очереди | Всегда возвращает bool |
| **Производительность** | Быстрее в однопоточности | Lock-free, оптимизирована для конкуренции |

### Важные особенности ConcurrentQueue

**Lock-free реализация**: Использует атомарные операции вместо блокировок, что обеспечивает высокую производительность.

**Count не точный**: В многопоточной среде значение может устареть к моменту использования.

**Отсутствие блокирующих методов**: Все операции неблокирующие - если элемента нет, метод возвращает `false`, а не ждет.

**Практическое правило**: Используйте `ConcurrentQueue` в сценариях producer-consumer, где несколько потоков добавляют/извлекают элементы.

# `ConcurrentStack` - LIFO стек  

## Ключевые отличия

| Критерий | Stack | ConcurrentStack |
|----------|-------|-----------------|
| **Потокобезопасность** | ❌ Нет | ✅ Полная |
| **Pop()** | ✅ Есть, бросает исключение | ❌ Нет - только TryPop() |
| **Peek()** | ✅ Есть, бросает исключение | ❌ Нет - только TryPeek() |
| **Массовые операции** | ❌ Нет | ✅ PushRange(), TryPopRange() |
| **Count** | Точное значение | ⚠️ Приблизительное |
| **IsEmpty** | ❌ Нет | ✅ Есть |
| **Исключения** | InvalidOperationException при пустом стеке | Всегда возвращает bool |
| **Производительность** | Быстрее в однопоточности | Lock-free, оптимизирована для конкуренции |

## Важные особенности ConcurrentStack

**LIFO порядок**: Последний добавленный элемент извлекается первым - полезно для отмены операций или обработки в обратном порядке.

**PushRange/TryPopRange**: Уникальные методы для массовых операций, повышающие производительность при работе с большими объемами данных.

**Lock-free реализация**: Как и другие concurrent коллекции, использует атомарные операции для высокой производительности.

**Count нестабилен**: В многопоточной среде может измениться между проверкой и использованием.

**Практическое применение**: Отлично подходит для undo-операций, рекурсивных алгоритмов в параллельной обработке, или когда нужен обратный порядок обработки элементов.


# `ConcurrentBag` - неупорядоченная коллекция

## Ключевые отличия

| Критерий | List | ConcurrentBag |
|----------|---------|------------------|
| **Потокобезопасность** | ❌ Нет | ✅ Полная |
| **Порядок элементов** | ✅ Сохраняется | ❌ НЕ гарантируется |
| **Индексный доступ** | ✅ list[index] | ❌ Нет |
| **Удаление конкретного элемента** | ✅ Remove(item) | ❌ Только TryTake() |
| **Производительность добавления** | Быстрая | ✅ Очень быстрая (thread-local) |
| **Поиск элементов** | ✅ IndexOf, Contains | ⚠️ Только через перебор |
| **Count** | Точное значение | ⚠️ Приблизительное |
| **Назначение** | Упорядоченный список | Неупорядоченная коллекция |

## Важные особенности ConcurrentBag

**Thread-local storage**: Каждый поток имеет свою локальную коллекцию, что минимизирует конкуренцию и блокировки.

**Отсутствие порядка**: Элементы могут быть извлечены в любом порядке - это не баг, а особенность.

**TryTake() оптимизирован**: Сначала пытается взять из локального хранилища текущего потока, затем "крадет" из других потоков.

**Нет индексов**: Нельзя получить элемент по позиции - только добавить или извлечь произвольный.

## Когда использовать ConcurrentBag

```csharp
// ✅ Хорошо: Сбор результатов параллельной обработки
Parallel.ForEach(data, item => 
{
    var result = Process(item);
    results.Add(result); // Порядок не важен
});

// ❌ Плохо: Когда нужен определенный порядок
// Не используйте для очередей или стеков
```

**Практическое правило**: Используйте `ConcurrentBag` когда нужна быстрая потокобезопасная коллекция для накопления данных без требований к порядку - идеально для результатов параллельных вычислений.

**Для Producer-Consumer:**
# `BlockingCollection` - с возможностями блокировки и ограничения

## Зачем нужна BlockingCollection

1. **Автоматическое управление потоком данных**
- **ConcurrentQueue**: Нужно вручную проверять `IsEmpty` и делать `Thread.Sleep()` в циклах
- **BlockingCollection**: Автоматически блокирует поток до появления данных

2. **Контроль переполнения (Backpressure)**
- **Bounded capacity** предотвращает неконтролируемый рост памяти
- Производители автоматически замедляются если потребители не успевают
- Защита от OutOfMemoryException в высоконагруженных системах

3. **Корректное завершение работы**
- **CompleteAdding()** сигнализирует потребителям о завершении
- Потребители автоматически завершаются после обработки последних элементов
- Избегает "зависших" потребителей в бесконечных циклах

4. **Устранение активного ожидания (Busy Wait)**
- **ConcurrentQueue** требует постоянных проверок с `Thread.Sleep()`
- **BlockingCollection** использует эффективное ожидание на kernel-уровне
- Экономия CPU ресурсов

5. **Упрощение Producer-Consumer паттерна**
- Один класс решает все проблемы многопоточности
- Убирает необходимость в ручном управлении синхронизацией
- Меньше багов связанных с race conditions

6. **Гибкость внутренней реализации**
- Можно использовать любую `IProducerConsumerCollection`
- FIFO (Queue), LIFO (Stack), неупорядоченные (Bag) коллекции
- Единый интерфейс для разных стратегий

7. **Таймауты и отмена операций**
- Встроенная поддержка `CancellationToken`
- Таймауты для Add/Take операций
- Предотвращение deadlock'ов

**Суть**: BlockingCollection превращает сложный многопоточный паттерн в простой, надежный и эффективный инструмент с автоматическим управлением жизненным циклом.


## Основные методы BlockingCollection

### Методы добавления

**Add(item)**
Добавляет элемент, блокируется если коллекция заполнена.

```csharp
var collection = new BlockingCollection(capacity: 3);
collection.Add(1); // Добавляет элемент
collection.Add(2); // Добавляет элемент
collection.Add(3); // Добавляет элемент
collection.Add(4); // Блокируется до освобождения места
```

**TryAdd(item, timeout)**
Пытается добавить элемент с таймаутом.

```csharp
bool success = collection.TryAdd(5, TimeSpan.FromSeconds(1));
if (!success) 
{
    Console.WriteLine("Не удалось добавить за 1 секунду");
}
```

### Методы извлечения

**Take()**
Извлекает элемент, блокируется если коллекция пуста.

```csharp
int item = collection.Take(); // Блокируется до появления элемента
```

**TryTake(out item, timeout)**
Пытается извлечь элемент с таймаутом.

```csharp
if (collection.TryTake(out int item, TimeSpan.FromSeconds(30)))
{
    Console.WriteLine($"Получен: {item}");
}
else
{
    Console.WriteLine("Нет элементов 30 секунд");
}
```

### Управление жизненным циклом

**CompleteAdding()**
Сигнализирует, что больше элементов не будет.

```csharp
collection.CompleteAdding(); // После этого Add() будет бросать исключение
```

**GetConsumingEnumerable()**
Перебирает элементы до завершения коллекции.

```csharp
foreach (var item in collection.GetConsumingEnumerable())
{
    Console.WriteLine(item); // Обрабатывает элементы до CompleteAdding()
}
```

### Работа с несколькими коллекциями

**AddToAny(collections[], item)**
Добавляет в любую доступную коллекцию.

```csharp
var collections = new[] { collection1, collection2, collection3 };
int index = BlockingCollection.AddToAny(collections, 42);
Console.WriteLine($"Добавлено в коллекцию {index}");
```

**TakeFromAny(collections[], out item)**
Извлекает из любой доступной коллекции.

```csharp
int index = BlockingCollection.TakeFromAny(collections, out int item);
Console.WriteLine($"Взято {item} из коллекции {index}");
```

## Свойства состояния

| Свойство | Описание |
|----------|----------|
| **IsCompleted** | Коллекция пуста И CompleteAdding() вызван |
| **IsAddingCompleted** | CompleteAdding() вызван |
| **Count** | Приблизительное количество элементов |
| **BoundedCapacity** | Максимальная емкость коллекции |

## Пример полного жизненного цикла

```csharp
var collection = new BlockingCollection(5);

// Producer
Task.Run(() => {
    collection.Add("Item1");
    collection.Add("Item2"); 
    collection.CompleteAdding();
});

// Consumer
foreach (var item in collection.GetConsumingEnumerable())
{
    Console.WriteLine($"Обработан: {item}");
}
// Цикл автоматически завершится после CompleteAdding()
```

**Ключевая особенность**: Методы без `Try` блокируют поток, методы с `Try` возвращают `bool` и поддерживают таймауты.


## Ключевые отличия

| Критерий | Queue + ручные блокировки | BlockingCollection |
|----------|---------------------------|-------------------|
| **Простота реализации** | ❌ Сложно, много кода | ✅ Готовое решение |
| **Блокирующие операции** | ⚠️ Нужно реализовывать | ✅ Take(), Add() |
| **Ограничение размера** | ⚠️ Нужно реализовывать | ✅ boundedCapacity |
| **Таймауты** | ⚠️ Сложная реализация | ✅ TryAdd(), TryTake() |
| **Завершение работы** | ⚠️ Управление вручную | ✅ CompleteAdding() |
| **Перебор** | ❌ Сложно | ✅ GetConsumingEnumerable() |
| **Производительность** | Зависит от реализации | ✅ Оптимизированная |
| **Безопасность потоков** | ⚠️ Ответственность разработчика | ✅ Гарантированная |

## Важные особенности BlockingCollection

**Bounded capacity**: Ограничивает размер коллекции - производители блокируются при переполнении.

**CompleteAdding()**: Критически важный метод для корректного завершения работы потребителей.

**GetConsumingEnumerable()**: Удобный способ перебора с автоматическим завершением когда коллекция закрыта.

**Обертка над IProducerConsumerCollection**: По умолчанию использует `ConcurrentQueue`, но можно передать другую реализацию.

## Методы работы с таймаутами

```csharp
// Добавление с таймаутом
bool added = collection.TryAdd(item, 1000); // 1 секунда
bool added2 = collection.TryAdd(item, TimeSpan.FromSeconds(5));

// Извлечение с таймаутом
bool taken = collection.TryTake(out int result, 500); // 500 мс
bool taken2 = collection.TryTake(out int result2, TimeSpan.FromMinutes(1));
```

**Практическое правило**: Используйте `BlockingCollection` для классических Producer-Consumer сценариев где нужны блокирующие операции и управление жизненным циклом коллекции.

### 4. **Практические сценарии применения**
Когда использовать каждый тип: чистый producer-consumer vs смешанный сценарий.

### 5. **Производительность и best practices**
Накладные расходы синхронизации, когда потокобезопасные коллекции быстрее обычных с внешними блокировками.

### 6. **Живые примеры кода**
Показать Try* методы, атомарные операции, правильные паттерны использования.

Такая последовательность: **проблема → решение → инструменты → применение → оптимизация → практика**.
