## В чём отличие асинхронности и многопоточности

Ниже приведена сравнительная таблица основных отличий и связей асинхронного программирования и многопоточности.

|Характеристика|Асинхронность|Многопоточность|
|--|--|--|
|Модель выполнения|Цикл событий и `async/await` в едином потоке, переключение в строго определённых точках|Несколько активных ОС-потоков, выполняющихся параллельно на разных ядрах CPU|
|Использование ресурсов|Минимальное число потоков, избегание блокировок при I/O, низкие накладные расходы на переключение контекста|Выделение и переключение между потоками, рост потребления памяти и времени на синхронизацию|
|Сложность|Упрощённая синхронизация через явные точки ожидания и коллбэки, меньше риска гонок|Требуется управление блокировками, семафорами, предотвращение взаимных блокировок и гонок|
|Взаимосвязь|Под капотом задействует потоки или пул потоков для фоновых операций, но не создаёт новые без необходимости|Низкоуровневая модель: разработчик напрямую управляет созданием, синхронизацией и жизненным циклом потоков|
|Когда применять|I/O-интенсивные задачи (сетевые запросы, файловый ввод-вывод, БД)|CPU-интенсивные задачи (тяжёлые вычисления, обработка больших объёмов данных)|

### Отличия

Асинхронное программирование уделяет особое внимание на неблокирующем выполнении длительных операций (обычно ввода-вывода), позволяя основному потоку продолжать работу без ожидания результата. Многопоточность же предполагает непосредственное параллельное исполнение кода на нескольких потоках, часто с целью распараллеливания вычислительно тяжёлых задач.

### Основные отличия  
- **Модель выполнения**: асинхронность обычно опирается на цикл событий (event loop) и коллбэки или `async/await`, при этом задачи выполняются в едином потоке, а переключение происходит в строго заданных точках. Многопоточность создаёт несколько активных потоков, каждый из которых может выполняться независимо и одновременно на разных ядрах процессора.  

- **Использование ресурсов**: асинхронность минимизирует число потоков, избегая их блокировки при ожидании (I/O), что снижает накладные расходы на переключение контекста и память. Многопоточность подразумевает выделение и переключение между потоками, что даёт реальный параллелизм, но может приводить к росту потребления памяти и времени на синхронизацию.  

- **Сложность**: асинхронный код легче контролировать с точки зрения синхронизации, поскольку все операции сводятся к последовательным шагам с явными точками ожидания. Многопоточный код требует аккуратного управления доступом к общим ресурсам (блокировки, семафоры), чтобы избежать гонок и взаимных блокировок.  

### Взаимосвязь  
- Под капотом многие асинхронные библиотеки используют потоки или пул потоков для выполнения фоновых задач, но основное отличие в том, что асинхронность фокусируется на эффективном использовании этих потоков, не создавая их без необходимости.  
- Многопоточность же является более низкоуровневым механизмом: вы напрямую управляете потоками, их жизненным циклом и синхронизацией, тогда как асинхронность даёт высокоуровневые абстракции для неблокирующих операций.  

### Когда применять  
- Асинхронность подходит для I/O-интенсивных задач: сетевые запросы, файловый ввод-вывод, взаимодействие с базой данных.  
- Многопоточность эффективна для CPU-bound задач: тяжёлые вычисления, обработка больших объёмов данных, где выигрыш от реального параллелизма многопоточного исполнения очевиден.  

Таким образом, асинхронное и многопоточное программирование решают разные задачи: первое оптимизирует ожидание, второе — расчёт. Тем не менее они дополняют друг друга и часто используются совместно для построения производительных и отзывчивых приложений.
